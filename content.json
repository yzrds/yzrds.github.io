{"meta":{"title":"梁友泽的博客","subtitle":null,"description":null,"author":"梁友泽","url":"http://www.liangyouze.com"},"pages":[{"title":"","date":"2018-10-27T05:22:46.921Z","updated":"2018-10-27T05:22:46.907Z","comments":true,"path":"about/index.html","permalink":"http://www.liangyouze.com/about/index.html","excerpt":"","text":"梁友泽个人信息 梁友泽 籍贯 重庆 本科/通信工程 2014-2018 Github https://github.com/yzrds 技术博客 https://www.liangyouze.com email: youzedev@gmail.com 工作年限 1年 技术方向 后端 工作经历xxxxx公司 (2018.03-2018.10)工作描述: xxxxx公司是一家外企，公司主要对外输出在线教育，视频会议录播，云会议服务等。个人职责:负责开发AculearnOnline在线教育产品，管理后台、以及日常业务开发。 主要技术: groovy,elasticsearch,mongodb,redis，kafka等互联网主流技术 职责描述: 参与整个在线教育平台从0到1的构建，微服务领域的划分。 负责整个支付系统设计与开发，并与业务子系统集成。 负责评价，kafka异步统计。部分单点登录与部分搜索。以及相关的订单模块。 整个管理后台的开发。 xxxx公司 (2017.09-2018.01)合同管理系统 项目描述: 合同管理项目为xxxx总部提供了从线下合同到线上合同管理的便捷服务。与ERP系统，人事管理系统集成。实现了可配置，，支持合同信息查询、合同审批、合同预算管控等功能，实现合同信息从线下管理到线上管理的初步功能。 主要技术:c#,bootstrap,oracle,jquery 工作描述:负责内部合同管理模块的研发实现工作，包括合同信息查询、合同审批、合同预算管控、文件上传、合同提示信息推送等功能，实现合同信息从线下管理到线上管理的初步功能。 技能清单 编程语言: java groovy golang 框架: SpringBoot/mybatis 存储: mysql/redis/mongo 中间件: kafka/elasticsearch 自我评价 习惯各种英文工作环境，能够较为熟练阅读各类技术的官方文档 有较强的学习能力和良好的学习习惯 数学爱好者，在校期间自学各类数学知识，并获得大学生数学建模竞赛省二等奖，网络挑战赛优秀奖。能把数学当小说看，但不扣细节。 热爱阅读，有长期维护的个人博客和微信公众号，喜欢交流与技术分享 为人踏实，具有较强的团队意识和协作能力"},{"title":"","date":"2018-11-25T14:42:26.500Z","updated":"2018-08-27T15:15:37.000Z","comments":true,"path":"archives/index.html","permalink":"http://www.liangyouze.com/archives/index.html","excerpt":"","text":"ceshi"},{"title":"Categories","date":"2018-11-18T12:34:28.410Z","updated":"2018-11-18T12:34:28.397Z","comments":true,"path":"categories/index.html","permalink":"http://www.liangyouze.com/categories/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-08-28T13:38:07.000Z","updated":"2018-08-28T13:38:07.000Z","comments":true,"path":"categories/index-LiangYouze-1.html","permalink":"http://www.liangyouze.com/categories/index-LiangYouze-1.html","excerpt":"","text":""}],"posts":[{"title":"我所读过的书","slug":"我所读过的书","date":"2018-10-10T12:10:33.000Z","updated":"2018-12-09T16:25:54.906Z","comments":true,"path":"2018/10/10/我所读过的书/","link":"","permalink":"http://www.liangyouze.com/2018/10/10/我所读过的书/","excerpt":"这里记录一下关于我读过的书籍","text":"这里记录一下关于我读过的书籍 2018年 Java JDK 7学习笔记 时间: 2018年1月18日 18:42:27 很久之前看的了。突然想标记一下。初学的话就花2h看一下吧。不太建议看的书 高效程序员的45个习惯：敏捷开发修炼之道 时间：2018年3月9日09:45:14 可能是现在还不是很注重，所以很快就浏览完了。我感觉工作半年内还是不读的好，这本书的价值不大 Mongo基础命令参考 时间：2018年3月18日23:11:02 一本野书，基本上就是熟悉一些Ｍｏｎｇｏｄｂ的命令，可以花１个小时浏览下就完了 JAVA编程思想 时间：2018年4月17日00:26:07 说实话，这本书真的是太长了，有精华的东西，同时也有淘汰的东西。距离上次记录书籍已经有一个月了，等再看的时候详细看一遍吧。 算法图解 时间：2018年5月14日00:41:01 Aditya Bhargava 作品，很不错的一本书，再加上是我非常喜欢的图灵教育出版的书。推荐读，而且讲的很形象。基础算法 人工智能 时间：2018年06月26日20:21:4５ 李开复的作品，对认知又多了一点，反正我是很相信人工智能带给社会的进步，以后必将是高科技与艺术的并存。工业上可以取代，但艺术不能取代。 Redis 入门指南 时间：2018年7月31日22:51:45 李子骅 编著 很好的一本基础书，命令很多。记了一些常用的。 Go语言编程 时间：2018年11月18日20:05:42 作者：许式伟 吕桂华 有点失望，给我的感觉就好像是Java一些所谓的“从入门到精通”一类的书，300页的书，看看目录其实有的人就会选择不看，但我还是看完了。深度也是点到为止，当然这其实是要自己去挖掘的。网络编程的那些其实我感觉就是翻译一些手册，也不是国外的文章。比较偏向于教科书方面的书 数学之美 时间：2018年12月06日09:22:58 作者：吴军 马尔可夫链是如此的熟悉，常见的新闻分类竟然是利用了余弦函数。其实大学阶段的知识真的是基础，比如说自然语言处理其实就可以抽象为比较简单的通信模型和统计学模型。利用一些概率公式然后再加上马尔科夫假设就可以做到机器翻译和语音识别。以及我现阶段最想做的搜索。其实布尔代数在支撑着搜索引擎索引的数学基础，当然要做好每个方向是要掌握本质以及精髓，做起事情来也会如诗般顺滑。 2017年 java解惑 这本书还好吧，反正让你会怀疑你的基础学的不扎实，新手老手都建议看一看，不过快速的看一下就好，花1天时间吧 图解HTTP 很好的一本书，值得一读 Java核心技术+卷1（原书第9版）》 这本书粗略过了，因为看的是pdf，打算再吧第十版看下 代码整洁之道 业界传闻的巴拉巴拉的必读书，同样建议看一看，好的代码格式，好的代码规范，以及注释等，也能体现一个人的水平。以前面试阿里的时候，就被问到代码规范之类的问题。建议多刻意练习。多看点源码，源码的规范就很好。","categories":[],"tags":[{"name":"读书","slug":"读书","permalink":"http://www.liangyouze.com/tags/读书/"}]},{"title":"","slug":"分布式架构","date":"2018-10-05T14:08:51.000Z","updated":"2018-10-05T14:08:51.000Z","comments":true,"path":"2018/10/05/分布式架构/","link":"","permalink":"http://www.liangyouze.com/2018/10/05/分布式架构/","excerpt":"","text":"分布式架构 在应用的迭代过程中，随着一些系统访问量高，用户数增多。业务复杂度提高，代码复杂度提高。应用逐渐从单体式架构面向服务的分布式架构转变。于是，RPC远程过程调用是分布式的核心。","categories":[],"tags":[]},{"title":"elasticsearch社区分享会","slug":"elasticsearch社区分享会","date":"2018-09-11T06:10:23.000Z","updated":"2018-10-08T05:46:01.000Z","comments":true,"path":"2018/09/11/elasticsearch社区分享会/","link":"","permalink":"http://www.liangyouze.com/2018/09/11/elasticsearch社区分享会/","excerpt":"在前段时间加班的时候错过了两场我想去的技术会，这次终于没落空了。大佬也多，涨了不少姿势。特此记录一下分享，由于全凭记忆叙述，可能就没啥顺序而言的还原出之前的收获。","text":"在前段时间加班的时候错过了两场我想去的技术会，这次终于没落空了。大佬也多，涨了不少姿势。特此记录一下分享，由于全凭记忆叙述，可能就没啥顺序而言的还原出之前的收获。 确实目前项目中目前涉及到了elasticsearch不多，索引都才几个。看到别人分享的都是2千，4-5千的索引量。而且数据量大的话才更能体现出elasticsearch的作用。 周金阳 果壳网/在行 算法工程师 算法果然是大佬，让es与深度学习结合起来在搜索这块已经走在很多公司的前面了吧。 使用 ES 来构建一个简易却行之有效的个性化推荐系统，以及一些高级搜索排序的实践。 搜索排序主要是分享一些机器学习工具与 ES 配合的实践心得。 思考一个问题，如果是这样的你会选择怎么排序1234&#123; \"title\":\"引力波\" \"content\":\"引力波引力波引力波\"&#125; 1234&#123; \"title\":\"引力波,一个世纪的求索\" \"content\":\"在物理学中，引力波是指时空弯曲中的涟漪，通过波的形式从辐射源向外传播，这种波以引力辐射的形式传输能量。在1916年，爱因斯坦基于广义相对论预言了引力波的存在。引力波的存在是广义相对论洛伦兹不变性的结果，因为它引入了相互作用的传播速度有限的概念。相比之下，引力波不能够存在于牛顿的经典引力理论当中，因为牛顿的经典理论假设物质的相互作用传播是速度无限的。\"&#125; 若输入的值和被检索到的结果呈线性变化g(q,x)很明显，第一个是用户测试的或者是胡乱写的，当用户输入“引力波”的时候，如何控制类似于这种情况让正常的显示在前。这种情况，就可以加一些其他的限制条件f(x),比如1得出来的期望值为15.42,2得出来的期望值为87.93，这样关于g(q,x) -&gt; f(x)*g(q,x) 当然如果要做的好的话需要优化的还有很多，比如用BiLSTM+CNN 期望后期会用到这些吧，毕竟我觉得这是偏离业务而且是和大数据接轨的之一。 其中，在使用es的时候有一些规范和约束， 业务索引尽量自定义id，数据敏感业务自备插入修改时间 一个索引一个type 控制单次搜索结果条数，总条数由es限制。控制请求超时时间 关于es的使用也有在调用链日志 一个节点一个主分片，0副本， 批量写入，控制单批写入字节数 在生产阶段，调用链日志写入慢，kafka会出现大量堆积等现象，关于如何解决。有以下方案， 索引写入时会伴随着id校验，请求体解析，分词等操作，都会带来一定的cpu开销。原先的索引结构中存在部分多余字段，无需进行分词，取消后可以减轻cpu压力。 使用es自动生成id，省去id检查步骤。调整translog合并时间，半小时一次，防止过多merge任务导致cpu开销过大。 在业务索引随着场景变化，写入量逐渐增多，集群cpu load变高，原来单个主分片写入出现瓶颈遇到这种情况 可以重建索引，主分片改为2个，分别分布在两台机器，达到负载均衡效果，数据需要迁移。 在提及到es时，不得不说也是和spark相关。这里就不展开讲了，下次深入了解的时候再学习。 番外大公司都是搜索是一个团队，虽然我业务写的也不好，但是我更倾向于这种方向。分享者都很强，有开发相关的以及运维，技术演变快，找准自己的一个兴趣点，专研下去。","categories":[],"tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://www.liangyouze.com/tags/elasticsearch/"}]},{"title":"关于生成订单号规则的一些思考","slug":"关于生成订单号规则的一些思考","date":"2018-08-10T12:10:33.000Z","updated":"2018-10-08T02:49:57.000Z","comments":true,"path":"2018/08/10/关于生成订单号规则的一些思考/","link":"","permalink":"http://www.liangyouze.com/2018/08/10/关于生成订单号规则的一些思考/","excerpt":"关于我为什么写这篇文章是因为今天在做订单模块的时候,看到之前的PRD上描述的订单生成规则是由 年月日＋用户id2位+企业id位＋四位自增长数。然后竟被我反驳的突然改成了精确时间＋4位自增长数，于是我更失望了。 我们考虑一下，据我所常见的订单基本都14-20位。(年月日时分秒和随机数)基本上就有14位了。虽然一般项目做不到淘宝双11这种支付峰值达到每秒10万笔订单.但是我觉得至少事先可以考虑到，想必当初淘宝或许也没意识到以后发展得这么好。","text":"关于我为什么写这篇文章是因为今天在做订单模块的时候,看到之前的PRD上描述的订单生成规则是由 年月日＋用户id2位+企业id位＋四位自增长数。然后竟被我反驳的突然改成了精确时间＋4位自增长数，于是我更失望了。 我们考虑一下，据我所常见的订单基本都14-20位。(年月日时分秒和随机数)基本上就有14位了。虽然一般项目做不到淘宝双11这种支付峰值达到每秒10万笔订单.但是我觉得至少事先可以考虑到，想必当初淘宝或许也没意识到以后发展得这么好。 背景为了达到业务订单的生成。我觉得要至少要符合以下这三种, 全局唯一 一定不能重复 在复杂的分布式系统中，很多场景需要的都是全局唯一ID的场景，一般为了防止冲突可以考虑的有36位的UUID,twitter的snowflake等。 但是可以思考这些问题？ 是不是应该有一些其他意义的思考，比如说订单系统有买家的id(取固定几位) 是否有商品的标识,方便熟悉业务的排查问题或者查询也通过不去系统查找可以有个初步的认识，但是业务量大的话感觉就可以排除这个人为的去辨识了。 个人的看法是主要是唯一，其他关于业务方面的不是太太重要。 查阅了相关资料，主要有以下这几种 UUID, 组成：当前日期+时间+时钟序列+机器识别号（Mac地址或其他）没有mac网卡的话会有别的东西识别。 在分布式系统中，所有元素（WEB服务器）都不需要通过中央控制端来判断数据唯一性。几十年之内可以达到全球唯一性。 snowflake的结构如下(每部分用-分开): Mysql通过AUTO_INCREMENT实现、Oracle通过Sequence序列实现。在数据库集群环境下，不同数据库节点可设置不同起步值、相同步长来实现集群下生产全局唯一、递增ID Snowflake算法 雪花算法 41位时间戳+10位机器ID+12位序列号（自增） 转化长度为18位的长整型。 Twitter为满足美秒上万条消息的创建，且ID需要趋势递增，方便客户端排序。 Snowflake虽然有同步锁，但是比uuid效率高。 Redis自增ID 实现了incr(key)用于将key的值递增1，并返回结果。如果key不存在，创建默认并赋值为0。 具有原子性，保证在并发的时候。 但是我在这主要想说的是雪花算法生成id,至于为什么，就测试了一下其他的，感觉这种生成方式个人比较喜欢。 Snowflake算法规则如下 使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 该算法实现基本是二进制操作。 一共加起来刚好64位，为一个Long型。(转换成字符串长度为18) snowflake生成的ID整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和workerId作区分），并且效率较高。据说：snowflake每秒能够产生26万个ID。 以下是代码部分借鉴与网络100万个ID 耗时２秒123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/** * Created by youze on 18-7-5 */public class IdWorker &#123; /** * 起始的时间戳 */ private final static long START_STMP = 1530795377086L; /** * 每一部分占用的位数 */ /** * 序列号占用的位数 */ private final static long SEQUENCE_BIT = 12; /** * 机器标识占用的位数 */ private final static long MACHINE_BIT = 5; /** * 数据中心占用的位数 */ private final static long DATACENTER_BIT = 5; /** * 每一部分的最大值 */ private final static long MAX_DATACENTER_NUM = -1L ^ (-1L &lt;&lt; DATACENTER_BIT); private final static long MAX_MACHINE_NUM = -1L ^ (-1L &lt;&lt; MACHINE_BIT); private final static long MAX_SEQUENCE = -1L ^ (-1L &lt;&lt; SEQUENCE_BIT); /** * 每一部分向左的位移 */ private final static long MACHINE_LEFT = SEQUENCE_BIT; private final static long DATACENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT; private final static long TIMESTMP_LEFT = DATACENTER_LEFT + DATACENTER_BIT; /** * 数据中心 */ private long datacenterId; /** * 机器标识 */ private long machineId; /** * 序列号 */ private long sequence = 0L; /** * 上一次时间戳 */ private long lastStmp = -1L; public IdWorker(long datacenterId, long machineId) &#123; if (datacenterId &gt; MAX_DATACENTER_NUM || datacenterId &lt; 0) &#123; throw new IllegalArgumentException(&quot;datacenterId can&apos;t be greater than MAX_DATACENTER_NUM or less than 0&quot;); &#125; if (machineId &gt; MAX_MACHINE_NUM || machineId &lt; 0) &#123; throw new IllegalArgumentException(&quot;machineId can&apos;t be greater than MAX_MACHINE_NUM or less than 0&quot;); &#125; this.datacenterId = datacenterId; this.machineId = machineId; &#125; /** * 产生下一个ID * @return */ public synchronized long nextId() &#123; long currStmp = getNewstmp(); if (currStmp &lt; lastStmp) &#123; throw new RuntimeException(&quot;Clock moved backwards. Refusing to generate id&quot;); &#125; if (currStmp == lastStmp) &#123; //相同毫秒内，序列号自增 sequence = (sequence + 1) &amp; MAX_SEQUENCE; //同一毫秒的序列数已经达到最大 if (sequence == 0L) &#123; currStmp = getNextMill(); &#125; &#125; else &#123; //不同毫秒内，序列号置为0 sequence = 0L; &#125; lastStmp = currStmp; return ( //时间戳部分 currStmp - START_STMP) &lt;&lt; TIMESTMP_LEFT //数据中心部分 | datacenterId &lt;&lt; DATACENTER_LEFT //机器标识部分 | machineId &lt;&lt; MACHINE_LEFT //序列号部分 | sequence; &#125; private long getNextMill() &#123; long mill = getNewstmp(); while (mill &lt;= lastStmp) &#123; mill = getNewstmp(); &#125; return mill; &#125; private long getNewstmp() &#123; return System.currentTimeMillis(); &#125; public static void main(String[] args) &#123; IdWorker snowFlake = new IdWorker(2, 3); long start = System.currentTimeMillis(); for (int i = 0; i &lt; 1000000; i++) &#123; System.out.println(snowFlake.nextId()); &#125; System.out.println(System.currentTimeMillis() - start); &#125;&#125; 最后大家可以看这也有更详细的解释","categories":[],"tags":[{"name":"订单号","slug":"订单号","permalink":"http://www.liangyouze.com/tags/订单号/"},{"name":"规则","slug":"规则","permalink":"http://www.liangyouze.com/tags/规则/"}]},{"title":"关于iframe跨域传输","slug":"关于iframe跨域传输","date":"2018-07-31T12:10:33.000Z","updated":"2018-10-08T05:52:24.000Z","comments":true,"path":"2018/07/31/关于iframe跨域传输/","link":"","permalink":"http://www.liangyouze.com/2018/07/31/关于iframe跨域传输/","excerpt":"至于我为什么想写这篇文章是因为最近在项目中使用到了iframe，是的。生无可恋的又写上了一点js，可能是因为前端的人对单点登录啥的或者是页面跳转以及要和后端的逻辑处理起来不是很熟练吧。各大网站，包括淘宝，京东，这些大网站有很多自己的产品，至于前期是怎么样的不是很清楚，网易云至少是用的iframe。参考了一些博客，至于使用不使用iframe，我觉得能解决问题就好，而且如果考虑的多的话就考虑以后扩展以及拆分啥的，毕竟前端又不像后端这样。","text":"至于我为什么想写这篇文章是因为最近在项目中使用到了iframe，是的。生无可恋的又写上了一点js，可能是因为前端的人对单点登录啥的或者是页面跳转以及要和后端的逻辑处理起来不是很熟练吧。各大网站，包括淘宝，京东，这些大网站有很多自己的产品，至于前期是怎么样的不是很清楚，网易云至少是用的iframe。参考了一些博客，至于使用不使用iframe，我觉得能解决问题就好，而且如果考虑的多的话就考虑以后扩展以及拆分啥的，毕竟前端又不像后端这样。 因为要解决跨域问题。有很多方案，比如说iframe，jsonp(不过只支持get，对于一些铭感信息就不行了) 原本需求是登录在一个站点，而注册是另外一个站点。因为要实时反馈到iframe子页面，子页面在进行相应。 而在Windows对象下有个postMessage方法，是解决跨越问题的假设有两个不同源的页面，iframe.html和index.html 其中前者是后者的子页面。123456789&lt;!-- index.html --&gt;&lt;body&gt; &lt;h1&gt;this is index&lt;/h1&gt; &lt;iframe src=\"./iframePage.html\" id='iframe'&gt;&lt;/iframe&gt;&lt;/body&gt; 1234567&lt;!-- iframePage --&gt;&lt;body&gt; &lt;h1&gt;this is iframePage&lt;/h1&gt;&lt;/body&gt; 现在这两个是无法通信的，因为是不同的站点，所以这个时候就要用到postMessage 123456789101112// idnex.html//获取iframe元素,当然也可以使用其他的js框架iFrame = document.getElementById('iframe')//iframe加载完毕后再发送消息，否则子页面接收不到messageiFrame.onload = function()&#123; //iframe加载完立即发送一条消息 iFrame.contentWindow.postMessage('MessageFromIndex1','*');&#125; 我们知道postMessage是挂载在window对象上的，所以等iframe加载完毕后，用iFrame.contentWindow获取到iframe的window对象，然后调用postMessage方法，相当于给子页面发送了一条消息。 postMessage方法第二个参数可以设置要发送到哪个url，如果当前子页面的url和设置的不一致，则会发送失败，因为没啥限制就设置为*，代表所有url都允许发送。 消息发送到iframePage.html，我们来接收message 123456789// iframePage.html//回调函数function receiveMessageFromIndex ( event ) &#123; console.log( 'receiveMessageFromIndex', event )&#125;//监听message事件window.addEventListener(\"message\", receiveMessageFromIndex, false); 然后设置好回调函数，就可以了，data中或许还有其他的数值，所以在接受的时候判断一下。","categories":[],"tags":[{"name":"跨域","slug":"跨域","permalink":"http://www.liangyouze.com/tags/跨域/"},{"name":"iframe","slug":"iframe","permalink":"http://www.liangyouze.com/tags/iframe/"}]},{"title":"初识Docker","slug":"关于docker","date":"2018-05-11T06:10:23.000Z","updated":"2018-11-18T12:42:13.953Z","comments":true,"path":"2018/05/11/关于docker/","link":"","permalink":"http://www.liangyouze.com/2018/05/11/关于docker/","excerpt":"关于dockerdocker是一款以容器虚拟化技术为基础的软件 那么什么是虚拟化技术 ？ 虚拟化技术是一种将计算机物理资源进行抽象、转换为虚拟的计算机资源提供给程序使用的技术。 因为要配置各种环境等，给开发造成了很多困扰。","text":"关于dockerdocker是一款以容器虚拟化技术为基础的软件 那么什么是虚拟化技术 ？ 虚拟化技术是一种将计算机物理资源进行抽象、转换为虚拟的计算机资源提供给程序使用的技术。 因为要配置各种环境等，给开发造成了很多困扰。 虚拟化还有一种作用，就是将虚拟化应用于资源管理。 假想一下，你要装mysql，redis等等，跑起一个服务端就比较费资源，虚拟化就可以很好地解决这件事情。就会有一种效果，那就是1+1&lt;2. 虚拟化技术通过资源隔离的方式，无形地也可以把这些程序隔离在不同的虚拟环境中，既然虚拟环境不同，自然运行在不同环境中的程序就不会互相干扰或争抢资源了。 docker的优势 基于容器技术的Docker拥有很高的跨平台性。Docker 的容器能够很轻松的运行在开发者本地的电脑，数据中心的物理机或虚拟机，云服务商提供的云服务器，甚至是混合环境中。 Docker 的轻量性和高可移植性能够很好的帮助我们完成应用的动态伸缩，我们可以通过一些手段近实时的对基于 Docker 运行的应用进行弹性伸缩，这能够大幅提高应用的健壮性。 不管是交付市场时间， 增加开发生产力，提高开发效率，节约基础设施成本，提升运维效率，以及加速问题解决时间。docker都有一个很好的作用。 关于docker的技术实现 Docker的实现，主要归结于三大技术，命令空间，控制组以及联合文件系统。大家可以更深入的去了解下。说到了Docker，就不得不先说说Docker的体系了。它有四个对象：镜像，容器，网络，数据卷。 镜像：大概可以理解为一个只读的文件包。其中包含了虚拟环境运行最原始文件系统的内容。镜像是对容器运行环境进行持久化存储的结果。 容器：容器就是用来隔离虚拟环境的基础设施，而在 Docker 里，它也被引申为隔离出来的虚拟环境。如果把镜像理解为编程中的类，那么容器就可以理解为类的实例。镜像内存放的是不可变化的东西，当以它们为基础的容器启动后，容器内也就成为了一个“活”的空间。 用更官方的定义来讲，Docker容器应该有三项内容组成。 一个Docker镜像 一个程序运行环境 一个指令集合 网络 对于大部分程序来说，它们的运行都不会是孤立的，而是要与外界或者更准确的说是与其他程序进行交互的，这里的交互绝大多数情况下指的就是数据信息的交换。网络通讯是目前最常用的一种程序间的数据交换方式了。 在 Docker 中，实现了强大的网络功能，我们不但能够十分轻松的对每个容器的网络进行配置，还能在容器间建立虚拟网络，将数个容器包裹其中，同时与其他网络环境隔离。 利用一些技术，Docker 能够在容器中营造独立的域名解析环境，这使得我们可以在不修改代码和配置的前提下直接迁移容器，Docker 会为我们完成新环境的网络适配。对于这个功能，我们甚至能够在不同的物理服务器间实现，让处在两台物理机上的两个 Docker 所提供的容器，加入到同一个虚拟网络中，形成完全屏蔽硬件的效果。 数据卷 在以往的虚拟机中，我们通常直接采用虚拟机的文件系统作为应用数据等文件的存储位置。然而这种方式其实并非完全安全的，当虚拟机或者容器出现问题导致文件系统无法使用时，虽然我们可以很快的通过镜像重置文件系统使得应用快速恢复运行，但是之前存放的数据也就消失了。 为了保证数据的独立性，我们通常会单独挂载一个文件系统来存放数据。这种操作在虚拟机中是繁琐的，因为我们不但要搞定挂载在不同宿主机中实现的方法，还要考虑挂载文件系统兼容性，虚拟操作系统配置等问题。值得庆幸的是，这些在 Docker 里都已经为我们轻松的实现了，我们只需要简单的一两个命令或参数，就能完成文件系统目录的挂载。","categories":[{"name":"docker","slug":"docker","permalink":"http://www.liangyouze.com/categories/docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://www.liangyouze.com/tags/Docker/"}]},{"title":"String、StringBuffer、StringBuilder三者之间的区别","slug":"String、StringBuffer、StringBuilder三者之间的区别","date":"2017-11-23T14:38:31.000Z","updated":"2018-10-08T05:51:52.000Z","comments":true,"path":"2017/11/23/String、StringBuffer、StringBuilder三者之间的区别/","link":"","permalink":"http://www.liangyouze.com/2017/11/23/String、StringBuffer、StringBuilder三者之间的区别/","excerpt":"吧啦吧啦，今天在公司做算法题的时候，不仅就想写下了 String是不可变类，所以任何对String的操作都将引发新的String对象的生成。但是StringBuffer是可变类，任何对StringBuffer所指代的字符串改变都不会产生新的对象。 新引入的StingBuilder类不是线程安全，但其在单线程中的性能比StringBuffer高。","text":"吧啦吧啦，今天在公司做算法题的时候，不仅就想写下了 String是不可变类，所以任何对String的操作都将引发新的String对象的生成。但是StringBuffer是可变类，任何对StringBuffer所指代的字符串改变都不会产生新的对象。 新引入的StingBuilder类不是线程安全，但其在单线程中的性能比StringBuffer高。 下面是一点小例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import java.util.ArrayList;import java.util.Iterator;import java.util.List;/** * 从JDK1.5中,有了StringBuilder。 */public class DifferenceStringBufferAndStringBuilder &#123; private static final String base = &quot;String&quot;; private static final int count = 3000000; public static void main(String[] args) &#123; stringTest(); stringBufferTest(); stringBuilderTest(); addToStringBuilder(); addToStringBuffer(); &#125; /** * string执行性能测试 */ public static void stringTest() &#123; long begin, end; begin = System.currentTimeMillis(); String test = new String(base); // 在这里为什么要缩150，因为其实时间是很长的 for (int i = 0; i &lt; count / 150; i++) &#123; test = test + &quot;add&quot;; &#125; end = System.currentTimeMillis(); System.out.println((end - begin) + &quot;millis has elapsed when used String&quot;); &#125; /** * stringBuffer */ public static void stringBufferTest() &#123; long begin, end; begin = System.currentTimeMillis(); StringBuffer stringBuffer = new StringBuffer(base); for (int i = 0; i &lt; count; i++) &#123; stringBuffer.append(&quot;add&quot;); &#125; end = System.currentTimeMillis(); System.out.println((end - begin) + &quot;millis has elapsed when used StringBuffer&quot;); &#125; /** * stingBuilder */ public static void stringBuilderTest() &#123; long begin, end; begin = System.currentTimeMillis(); StringBuilder stringBuilder = new StringBuilder(base); for (int i = 0; i &lt; count; i++) &#123; stringBuilder.append(&quot;add&quot;); &#125; end = System.currentTimeMillis(); System.out.println((end - begin) + &quot;mills has elapsed when used StringBuilder&quot;); &#125; /** *转换为StringBuilder */ public static String appendItemsToStringBuilder(List list)&#123; StringBuilder stringBuilder = new StringBuilder(); for (Iterator i = list.iterator();i.hasNext();)&#123; stringBuilder.append(i.next()).append(&quot;&quot;); &#125; return stringBuilder.toString(); &#125; public static void addToStringBuilder()&#123; List list = new ArrayList(); list.add(&quot;l&quot;); list.add(&quot;y&quot;); list.add(&quot;z&quot;); System.out.println(DifferenceStringBufferAndStringBuilder.appendItemsToStringBuilder(list)); &#125; public static String appendItemsToStringBuffer(List list)&#123; StringBuffer stringBuffer = new StringBuffer(); for (Iterator i = list.iterator();i.hasNext();)&#123; stringBuffer.append(i.next()).append(&quot;&quot;); &#125; return stringBuffer.toString(); &#125; public static void addToStringBuffer()&#123; List list = new ArrayList(); list.add(&quot;l&quot;); list.add(&quot;y&quot;); list.add(&quot;z&quot;); System.out.println(DifferenceStringBufferAndStringBuilder.appendItemsToStringBuffer(list)); &#125;&#125; 最后输出的是 123451127millis has elapsed when used String86millis has elapsed when used StringBuffer35mills has elapsed when used StringBuilderlyzlyz 所以根据结果来看，采用String对象时，哪怕是次数是其他对象的1/150,执行时间上也比其他对象高很多，而采用StringBuffer对象和采用StringBuilder对象也有明显的差距。所以如果是在单线程下运行，就不必考虑到线程同步的问题，优先采用StringBuilder类，当然，如果是要保证线程安全的话，就要考虑到StringBuffer了。 除了对多线程的支持不一样的话，其实这两个类没啥区别的，上面不就很好的说明了嘛。","categories":[],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://www.liangyouze.com/tags/字符串/"}]}]}