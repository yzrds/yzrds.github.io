{"meta":{"title":"梁友泽的博客","subtitle":null,"description":null,"author":"梁友泽","url":"http://www.liangyouze.com"},"pages":[{"title":"","date":"2018-08-27T15:15:37.085Z","updated":"2018-08-27T15:15:37.085Z","comments":true,"path":"archives/index.html","permalink":"http://www.liangyouze.com/archives/index.html","excerpt":"","text":"ceshi"},{"title":"","date":"2018-10-07T13:56:45.820Z","updated":"2018-10-07T13:56:45.820Z","comments":true,"path":"about/index.html","permalink":"http://www.liangyouze.com/about/index.html","excerpt":"","text":"梁友泽个人信息 梁友泽 籍贯 重庆 本科/通信工程 2014-2018 Github https://github.com/yzrds 技术博客 https://www.liangyouze.com wechat: lyz19951024 email: youzedev@gmail.com 工作年限 1年 技术方向 后端(未来想从事搜索方向) 工作经历新加坡艾克伦 (2018.03-至今)工作描述: 新加坡艾克伦是一家外企，公司主要对外输出在线教育，视频会议录播，云会议服务等。个人职责:负责开发AculearnOnline在线教育产品，管理后台、以及日常业务开发。 主要技术: groovy,elasticsearch,mongodb,redis，kafka等互联网主流技术 职责描述: 参与整个在线教育平台从0到1的构建，微服务领域的划分。 负责整个支付系统设计与开发，并与业务子系统集成。 负责评价，kafka异步统计。部分单点登录与部分搜索。以及相关的订单模块。 整个管理后台的开发。 重庆春之翼信息科技有限公司 (2017.09-2018.01)合同管理系统 项目描述: 合同管理项目为上海春秋航空总部提供了从线下合同到线上合同管理的便捷服务。与ERP系统，人事管理系统集成。实现了可配置，，支持合同信息查询、合同审批、合同预算管控等功能，实现合同信息从线下管理到线上管理的初步功能。 主要技术:c#,bootstrap,oracle,jquery 工作描述:负责内部合同管理模块的研发实现工作，包括合同信息查询、合同审批、合同预算管控、文件上传、合同提示信息推送等功能，实现合同信息从线下管理到线上管理的初步功能。 技能清单 编程语言: java groovy 框架: SpringBoot/mybatis 存储: mysql/redis/mongo 中间件: kafka/elasticsearch 自我评价 早已习惯各种英文工作环境，能够较为熟练阅读各类技术的官方文档 有较强的学习能力和良好的学习习惯 数学爱好者，在校期间自学各类数学知识，并获得大学生数学建模竞赛省二等奖，网络挑战赛优秀奖。能把数学当小说看，但不扣细节。 热爱阅读，有长期维护的个人博客和微信公众号，喜欢交流与技术分享 为人踏实，具有较强的团队意识和协作能力"},{"title":"categories","date":"2018-08-28T13:38:07.000Z","updated":"2018-08-28T13:38:07.748Z","comments":true,"path":"categories/index.html","permalink":"http://www.liangyouze.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"分布式架构","date":"2018-10-05T14:09:08.335Z","updated":"2018-10-05T14:08:51.734Z","comments":true,"path":"2018/10/05/分布式架构/","link":"","permalink":"http://www.liangyouze.com/2018/10/05/分布式架构/","excerpt":"","text":"分布式架构 在应用的迭代过程中，随着一些系统访问量高，用户数增多。业务复杂度提高，代码复杂度提高。应用逐渐从单体式架构面向服务的分布式架构转变。于是，RPC远程过程调用是分布式的核心。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-08-24T16:29:18.959Z","updated":"2018-08-24T16:29:18.959Z","comments":true,"path":"2018/08/25/hello-world/","link":"","permalink":"http://www.liangyouze.com/2018/08/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"关于生成订单号规则的一些思考","slug":"关于生成订单号规则的一些思考","date":"2018-08-10T12:10:33.000Z","updated":"2018-10-08T02:49:57.724Z","comments":true,"path":"2018/08/10/关于生成订单号规则的一些思考/","link":"","permalink":"http://www.liangyouze.com/2018/08/10/关于生成订单号规则的一些思考/","excerpt":"关于我为什么写这篇文章是因为今天在做订单模块的时候,看到之前的PRD上描述的订单生成规则是由 年月日＋用户id2位+企业id位＋四位自增长数。然后竟被我反驳的突然改成了精确时间＋4位自增长数，于是我更失望了。 我们考虑一下，据我所常见的订单基本都14-20位。(年月日时分秒和随机数)基本上就有14位了。虽然一般项目做不到淘宝双11这种支付峰值达到每秒10万笔订单.但是我觉得至少事先可以考虑到，想必当初淘宝或许也没意识到以后发展得这么好。","text":"关于我为什么写这篇文章是因为今天在做订单模块的时候,看到之前的PRD上描述的订单生成规则是由 年月日＋用户id2位+企业id位＋四位自增长数。然后竟被我反驳的突然改成了精确时间＋4位自增长数，于是我更失望了。 我们考虑一下，据我所常见的订单基本都14-20位。(年月日时分秒和随机数)基本上就有14位了。虽然一般项目做不到淘宝双11这种支付峰值达到每秒10万笔订单.但是我觉得至少事先可以考虑到，想必当初淘宝或许也没意识到以后发展得这么好。 背景为了达到业务订单的生成。我觉得要至少要符合以下这三种, 全局唯一 一定不能重复 在复杂的分布式系统中，很多场景需要的都是全局唯一ID的场景，一般为了防止冲突可以考虑的有36位的UUID,twitter的snowflake等。 但是可以思考这些问题？ 是不是应该有一些其他意义的思考，比如说订单系统有买家的id(取固定几位) 是否有商品的标识,方便熟悉业务的排查问题或者查询也通过不去系统查找可以有个初步的认识，但是业务量大的话感觉就可以排除这个人为的去辨识了。 个人的看法是主要是唯一，其他关于业务方面的不是太太重要。 查阅了相关资料，主要有以下这几种 UUID, 组成：当前日期+时间+时钟序列+机器识别号（Mac地址或其他）没有mac网卡的话会有别的东西识别。 在分布式系统中，所有元素（WEB服务器）都不需要通过中央控制端来判断数据唯一性。几十年之内可以达到全球唯一性。 snowflake的结构如下(每部分用-分开): Mysql通过AUTO_INCREMENT实现、Oracle通过Sequence序列实现。在数据库集群环境下，不同数据库节点可设置不同起步值、相同步长来实现集群下生产全局唯一、递增ID Snowflake算法 雪花算法 41位时间戳+10位机器ID+12位序列号（自增） 转化长度为18位的长整型。 Twitter为满足美秒上万条消息的创建，且ID需要趋势递增，方便客户端排序。 Snowflake虽然有同步锁，但是比uuid效率高。 Redis自增ID 实现了incr(key)用于将key的值递增1，并返回结果。如果key不存在，创建默认并赋值为0。 具有原子性，保证在并发的时候。 但是我在这主要想说的是雪花算法生成id,至于为什么，就测试了一下其他的，感觉这种生成方式个人比较喜欢。 Snowflake算法规则如下 使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 该算法实现基本是二进制操作。 一共加起来刚好64位，为一个Long型。(转换成字符串长度为18) snowflake生成的ID整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和workerId作区分），并且效率较高。据说：snowflake每秒能够产生26万个ID。 以下是代码部分借鉴与网络100万个ID 耗时２秒123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/** * Created by youze on 18-7-5 */public class IdWorker &#123; /** * 起始的时间戳 */ private final static long START_STMP = 1530795377086L; /** * 每一部分占用的位数 */ /** * 序列号占用的位数 */ private final static long SEQUENCE_BIT = 12; /** * 机器标识占用的位数 */ private final static long MACHINE_BIT = 5; /** * 数据中心占用的位数 */ private final static long DATACENTER_BIT = 5; /** * 每一部分的最大值 */ private final static long MAX_DATACENTER_NUM = -1L ^ (-1L &lt;&lt; DATACENTER_BIT); private final static long MAX_MACHINE_NUM = -1L ^ (-1L &lt;&lt; MACHINE_BIT); private final static long MAX_SEQUENCE = -1L ^ (-1L &lt;&lt; SEQUENCE_BIT); /** * 每一部分向左的位移 */ private final static long MACHINE_LEFT = SEQUENCE_BIT; private final static long DATACENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT; private final static long TIMESTMP_LEFT = DATACENTER_LEFT + DATACENTER_BIT; /** * 数据中心 */ private long datacenterId; /** * 机器标识 */ private long machineId; /** * 序列号 */ private long sequence = 0L; /** * 上一次时间戳 */ private long lastStmp = -1L; public IdWorker(long datacenterId, long machineId) &#123; if (datacenterId &gt; MAX_DATACENTER_NUM || datacenterId &lt; 0) &#123; throw new IllegalArgumentException(&quot;datacenterId can&apos;t be greater than MAX_DATACENTER_NUM or less than 0&quot;); &#125; if (machineId &gt; MAX_MACHINE_NUM || machineId &lt; 0) &#123; throw new IllegalArgumentException(&quot;machineId can&apos;t be greater than MAX_MACHINE_NUM or less than 0&quot;); &#125; this.datacenterId = datacenterId; this.machineId = machineId; &#125; /** * 产生下一个ID * @return */ public synchronized long nextId() &#123; long currStmp = getNewstmp(); if (currStmp &lt; lastStmp) &#123; throw new RuntimeException(&quot;Clock moved backwards. Refusing to generate id&quot;); &#125; if (currStmp == lastStmp) &#123; //相同毫秒内，序列号自增 sequence = (sequence + 1) &amp; MAX_SEQUENCE; //同一毫秒的序列数已经达到最大 if (sequence == 0L) &#123; currStmp = getNextMill(); &#125; &#125; else &#123; //不同毫秒内，序列号置为0 sequence = 0L; &#125; lastStmp = currStmp; return ( //时间戳部分 currStmp - START_STMP) &lt;&lt; TIMESTMP_LEFT //数据中心部分 | datacenterId &lt;&lt; DATACENTER_LEFT //机器标识部分 | machineId &lt;&lt; MACHINE_LEFT //序列号部分 | sequence; &#125; private long getNextMill() &#123; long mill = getNewstmp(); while (mill &lt;= lastStmp) &#123; mill = getNewstmp(); &#125; return mill; &#125; private long getNewstmp() &#123; return System.currentTimeMillis(); &#125; public static void main(String[] args) &#123; IdWorker snowFlake = new IdWorker(2, 3); long start = System.currentTimeMillis(); for (int i = 0; i &lt; 1000000; i++) &#123; System.out.println(snowFlake.nextId()); &#125; System.out.println(System.currentTimeMillis() - start); &#125;&#125; 最后大家可以看这也有更详细的解释","categories":[],"tags":[{"name":"订单号","slug":"订单号","permalink":"http://www.liangyouze.com/tags/订单号/"},{"name":"规则","slug":"规则","permalink":"http://www.liangyouze.com/tags/规则/"}]},{"title":"关于iframe跨域传输","slug":"关于iframe跨域传输","date":"2018-07-31T12:10:33.000Z","updated":"2018-09-02T15:06:08.114Z","comments":true,"path":"2018/07/31/关于iframe跨域传输/","link":"","permalink":"http://www.liangyouze.com/2018/07/31/关于iframe跨域传输/","excerpt":"","text":"至于我为什么想写这篇文章是因为最近在项目中使用到了iframe，是的。生无可恋的又写上了一点js，可能是因为前端的人对单点登录啥的或者是页面跳转以及要和后端的逻辑处理起来不是很熟练吧。各大网站，包括淘宝，京东，这些大网站有很多自己的产品，至于前期是怎么样的不是很清楚，网易云至少是用的iframe。参考了一些博客，至于使用不使用iframe，我觉得能解决问题就好，而且如果考虑的多的话就考虑以后扩展以及拆分啥的，毕竟前端又不像后端这样。 因为要解决跨域问题。有很多方案，比如说iframe，jsonp(不过只支持get，对于一些铭感信息就不行了) 原本需求是登录在一个站点，而注册是另外一个站点。因为要实时反馈到iframe子页面，子页面在进行相应。 而在Windows对象下有个postMessage方法，是解决跨越问题的假设有两个不同源的页面，iframe.html和index.html 其中前者是后者的子页面。123456789&lt;!-- index.html --&gt;&lt;body&gt; &lt;h1&gt;this is index&lt;/h1&gt; &lt;iframe src=\"./iframePage.html\" id='iframe'&gt;&lt;/iframe&gt;&lt;/body&gt; 1234567&lt;!-- iframePage --&gt;&lt;body&gt; &lt;h1&gt;this is iframePage&lt;/h1&gt;&lt;/body&gt; 现在这两个是无法通信的，因为是不同的站点，所以这个时候就要用到postMessage 123456789101112// idnex.html//获取iframe元素,当然也可以使用其他的js框架iFrame = document.getElementById('iframe')//iframe加载完毕后再发送消息，否则子页面接收不到messageiFrame.onload = function()&#123; //iframe加载完立即发送一条消息 iFrame.contentWindow.postMessage('MessageFromIndex1','*');&#125; 我们知道postMessage是挂载在window对象上的，所以等iframe加载完毕后，用iFrame.contentWindow获取到iframe的window对象，然后调用postMessage方法，相当于给子页面发送了一条消息。 postMessage方法第二个参数可以设置要发送到哪个url，如果当前子页面的url和设置的不一致，则会发送失败，因为没啥限制就设置为*，代表所有url都允许发送。 消息发送到iframePage.html，我们来接收message 123456789// iframePage.html//回调函数function receiveMessageFromIndex ( event ) &#123; console.log( 'receiveMessageFromIndex', event )&#125;//监听message事件window.addEventListener(\"message\", receiveMessageFromIndex, false); 然后设置好回调函数，就可以了，data中或许还有其他的数值，所以在接受的时候判断一下。","categories":[],"tags":[{"name":"跨域","slug":"跨域","permalink":"http://www.liangyouze.com/tags/跨域/"},{"name":"iframe","slug":"iframe","permalink":"http://www.liangyouze.com/tags/iframe/"}]},{"title":"w","slug":"w","date":"2018-05-24T16:51:18.000Z","updated":"2018-08-26T06:11:17.525Z","comments":true,"path":"2018/05/25/w/","link":"","permalink":"http://www.liangyouze.com/2018/05/25/w/","excerpt":"","text":"","categories":[],"tags":[]}]}